import { existsSync } from "node:fs";
import { mkdir, readFile, writeFile } from "node:fs/promises";
import { join } from "node:path";
import type { StateManager } from "@/state";
import type { CapabilityType, EvolvedCapability, Pattern } from "@/types";

interface EvolutionSuggestion {
  type: CapabilityType;
  name: string;
  description: string;
  reason: string;
  pattern: Pattern;
}

function generateToolCode(name: string, description: string, pattern: Pattern): string {
  const funcName = name.replace(/-/g, "_");
  return `// ðŸ“¦ Auto-generated by Mimic
// Pattern: ${pattern.description} (${pattern.count}x)
// Generated: ${new Date().toISOString()}

export const ${funcName} = (plugin) => ({
  tool: {
    "${name}": {
      description: "${description}",
      args: {},
      async execute() {
        // TODO: Implement your logic here
        // This was generated from pattern: ${pattern.description}
        return "ðŸ“¦ ${name} executed!";
      },
    },
  },
});

export default ${funcName};
`;
}

function generateHookCode(name: string, _description: string, pattern: Pattern): string {
  const filename = pattern.description;
  return `// ðŸ“¦ Auto-generated by Mimic
// Pattern: ${pattern.description} (${pattern.count}x)
// Generated: ${new Date().toISOString()}

export const ${name.replace(/-/g, "_")} = (plugin) => ({
  async event({ event }) {
    if (event.type === "file.edited") {
      const filename = event.properties?.filename;
      if (filename?.includes("${filename}")) {
        console.log("ðŸ“¦ [Mimic] Detected change in watched file: ${filename}");
        // TODO: Add your custom logic here
      }
    }
  },
});

export default ${name.replace(/-/g, "_")};
`;
}

function generateSkillCode(name: string, description: string, pattern: Pattern): string {
  return `// ðŸ“¦ Auto-generated by Mimic
// Pattern: ${pattern.description} (${pattern.count}x)
// Generated: ${new Date().toISOString()}

export const ${name.replace(/-/g, "_")} = (plugin) => ({
  async event({ event }) {
    // Auto-triggered skill: ${description}
    if (event.type === "session.created") {
      console.log("ðŸ“¦ [Mimic] Skill ${name} activated");
      // TODO: Implement automated behavior
    }
  },
});

export default ${name.replace(/-/g, "_")};
`;
}

function generateMcpConfig(name: string, _description: string, pattern: Pattern): object {
  return {
    [name]: {
      type: "local",
      command: ["echo", `MCP server for ${pattern.description}`],
      enabled: false,
    },
  };
}

function generateAgentMarkdown(name: string, description: string, pattern: Pattern): string {
  return `---
description: ${description}
mode: subagent
tools:
  read: true
  glob: true
  grep: true
  bash: false
  edit: false
---

# ðŸ“¦ ${name}

Auto-generated by Mimic from pattern: ${pattern.description} (${pattern.count}x)

## Focus Area

This agent specializes in tasks related to: ${pattern.description}

## Context

- Pattern detected: ${pattern.type}
- Usage count: ${pattern.count}
- First seen: ${new Date(pattern.firstSeen).toISOString()}

## How To Help

Analyze and assist with tasks matching this pattern.
Provide focused, expert guidance in this specific area.

## Remember

- Stay focused on the pattern's domain
- Leverage the observed usage patterns
- Adapt to the user's workflow
`;
}

type EvolutionOutput = { filePath: string; content: string };

async function readOpencodeConfig(configPath: string): Promise<Record<string, unknown>> {
  if (!existsSync(configPath)) return {};

  try {
    const parsed = JSON.parse(await readFile(configPath, "utf-8"));
    if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) {
      return {};
    }
    return parsed as Record<string, unknown>;
  } catch {
    return {};
  }
}

async function buildMcpEvolution(
  suggestion: EvolutionSuggestion,
  directory: string,
): Promise<EvolutionOutput> {
  const opencodeDir = join(directory, ".opencode");
  if (!existsSync(opencodeDir)) {
    await mkdir(opencodeDir, { recursive: true });
  }

  const configPath = join(directory, "opencode.json");
  const config = await readOpencodeConfig(configPath);
  const mcpConfig = generateMcpConfig(
    suggestion.name,
    suggestion.description,
    suggestion.pattern,
  );

  const mcp = { ...((config.mcp as Record<string, unknown>) || {}), ...mcpConfig };
  const content = JSON.stringify({ ...config, mcp }, null, 2);

  return { filePath: configPath, content };
}

async function buildAgentEvolution(
  suggestion: EvolutionSuggestion,
  directory: string,
): Promise<EvolutionOutput> {
  const agentsDir = join(directory, ".opencode", "agents");
  if (!existsSync(agentsDir)) {
    await mkdir(agentsDir, { recursive: true });
  }

  return {
    content: generateAgentMarkdown(suggestion.name, suggestion.description, suggestion.pattern),
    filePath: join(agentsDir, `${suggestion.name}.md`),
  };
}

function buildPluginContent(suggestion: EvolutionSuggestion): string {
  switch (suggestion.type) {
    case "command":
    case "shortcut":
      return generateToolCode(suggestion.name, suggestion.description, suggestion.pattern);
    case "hook":
      return generateHookCode(suggestion.name, suggestion.description, suggestion.pattern);
    case "skill":
      return generateSkillCode(suggestion.name, suggestion.description, suggestion.pattern);
    default:
      return generateToolCode(suggestion.name, suggestion.description, suggestion.pattern);
  }
}

async function buildPluginEvolution(
  suggestion: EvolutionSuggestion,
  directory: string,
): Promise<EvolutionOutput> {
  const pluginsDir = join(directory, ".opencode", "plugins");
  if (!existsSync(pluginsDir)) {
    await mkdir(pluginsDir, { recursive: true });
  }

  return {
    content: buildPluginContent(suggestion),
    filePath: join(pluginsDir, `${suggestion.name}.js`),
  };
}

async function buildEvolutionOutput(
  suggestion: EvolutionSuggestion,
  directory: string,
): Promise<EvolutionOutput> {
  if (suggestion.type === "mcp") {
    return buildMcpEvolution(suggestion, directory);
  }

  if (suggestion.type === "agent") {
    return buildAgentEvolution(suggestion, directory);
  }

  return buildPluginEvolution(suggestion, directory);
}

function createCapabilityFromSuggestion(suggestion: EvolutionSuggestion): EvolvedCapability {
  return {
    id: crypto.randomUUID(),
    type: suggestion.type,
    name: suggestion.name,
    description: suggestion.description,
    createdAt: new Date().toISOString(),
    fromPattern: suggestion.pattern.id,
  };
}

function updateEvolutionState(
  state: Awaited<ReturnType<StateManager["read"]>>,
  capability: EvolvedCapability,
  suggestion: EvolutionSuggestion,
): void {
  state.evolution.capabilities.push(capability);
  state.evolution.lastEvolution = new Date().toISOString();

  const pattern = state.patterns.find((p) => p.id === suggestion.pattern.id);
  if (pattern) {
    pattern.surfaced = true;
  }
}

export function suggestEvolution(pattern: Pattern): EvolutionSuggestion | null {
  switch (pattern.type) {
    case "tool":
      if (pattern.count >= 10) {
        return {
          type: "shortcut",
          name: `quick-${pattern.description.toLowerCase().replace(/[^a-z0-9]/g, "-")}`,
          description: `Shortcut for frequent ${pattern.description} usage`,
          reason: `Used ${pattern.count} times`,
          pattern,
        };
      }
      break;

    case "file":
      if (pattern.count >= 5) {
        return {
          type: "hook",
          name: `watch-${pattern.description.split("/").pop()?.replace(/\./g, "-") || "file"}`,
          description: `Auto-track changes to ${pattern.description}`,
          reason: `Modified ${pattern.count} times`,
          pattern,
        };
      }
      break;

    case "commit":
      if (pattern.count >= 3) {
        return {
          type: "command",
          name: `commit-${pattern.description.slice(0, 20).replace(/\s+/g, "-").toLowerCase()}`,
          description: `Quick commit: "${pattern.description}"`,
          reason: `Committed ${pattern.count} times with same message`,
          pattern,
        };
      }
      break;

    case "sequence":
      if (pattern.count >= 5) {
        return {
          type: "agent",
          name: `${pattern.description.slice(0, 15).replace(/\s+/g, "-").toLowerCase()}-specialist`,
          description: `Specialist agent for: ${pattern.description}`,
          reason: `Complex sequence repeated ${pattern.count} times - needs dedicated agent`,
          pattern,
        };
      }
      if (pattern.count >= 3) {
        return {
          type: "skill",
          name: `auto-${pattern.description.slice(0, 15).replace(/\s+/g, "-").toLowerCase()}`,
          description: `Automate: ${pattern.description}`,
          reason: `Repeated sequence ${pattern.count} times`,
          pattern,
        };
      }
      break;
  }

  return null;
}

export async function getEvolutionSuggestions(
  stateManager: StateManager,
): Promise<EvolutionSuggestion[]> {
  const state = await stateManager.read();
  const suggestions: EvolutionSuggestion[] = [];

  for (const pattern of state.patterns) {
    if (pattern.surfaced) continue;

    const suggestion = suggestEvolution(pattern);
    if (suggestion) {
      suggestions.push(suggestion);
    }
  }

  return suggestions;
}

export async function evolveCapability(
  stateManager: StateManager,
  suggestion: EvolutionSuggestion,
  directory: string,
): Promise<{ capability: EvolvedCapability; filePath: string }> {
  const state = await stateManager.read();
  const { filePath, content } = await buildEvolutionOutput(suggestion, directory);
  await writeFile(filePath, content, "utf-8");

  const capability = createCapabilityFromSuggestion(suggestion);
  updateEvolutionState(state, capability, suggestion);

  await stateManager.save(state);
  await stateManager.addMilestone(`Evolved: ${capability.name} (${capability.type})`);

  return { capability, filePath };
}

export function formatEvolutionResult(capability: EvolvedCapability, filePath: string): string {
  let result = `### âœ¨ ${capability.name}\n\n`;
  result += `**Type**: ${capability.type}\n`;
  result += `**Description**: ${capability.description}\n`;
  result += `**File created**: \`${filePath}\`\n\n`;
  result += `*Restart OpenCode to load the new ${capability.type}.*\n\n`;

  switch (capability.type) {
    case "command":
    case "shortcut":
      result += `The tool \`${capability.name}\` will be available after restart.\n`;
      result += `Edit the file to customize its behavior.\n`;
      break;

    case "hook":
      result += `The hook will automatically watch for file changes after restart.\n`;
      result += `Edit the file to customize the trigger conditions.\n`;
      break;

    case "skill":
      result += `The skill will activate on session start after restart.\n`;
      result += `Edit the file to customize when and how it triggers.\n`;
      break;

    case "agent":
      result += `The agent \`@${capability.name}\` will be available after restart.\n`;
      result += `You can invoke it with \`@${capability.name}\` or let other agents delegate to it.\n`;
      result += `Edit the markdown file to customize its prompt, tools, and permissions.\n`;
      break;

    case "mcp":
      result += `MCP server \`${capability.name}\` has been added to \`opencode.json\`.\n`;
      result += `It's currently disabled. Edit the config to enable it and configure the command.\n`;
      result += `See https://opencode.ai/docs/mcp-servers/ for MCP configuration options.\n`;
      break;
  }

  return result;
}
